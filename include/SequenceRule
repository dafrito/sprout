#ifndef SPROUT_SEQUENCERULE_HEADER
#define SPROUT_SEQUENCERULE_HEADER

#include <vector>
#include <algorithm>

#include "Cursor"
#include "Result"

namespace sprout {

template <class Rule>
class SequenceRule
{
public:
    typedef typename Rule::token_type token_type;
    typedef typename Rule::input_type input_type;

private:
    typedef typename Rule::token_type Token;
    typedef typename Rule::input_type Input;

private:
    bool _matchRequired;
    std::vector<Rule> _rules;

public:
    template <class Container>
    SequenceRule(const Container& rules, bool matchRequired = true) :
        _matchRequired(matchRequired),
        _rules(rules),
        _eof()
    {
    }

    const Result<Token> _eof;
    const Result<Token>& end() const
    {
        return _eof;
    }

    const Result<Token> parse(Cursor<Input>& iter) const
    {
        std::vector<Token> aggregate;
        for (auto rule : _rules) {
            auto tokens = rule.parse(iter);
            if (tokens != rule.end()) {
                std::copy(tokens, rule.end(), std::back_inserter(aggregate));
            } else if (_matchRequired) {
                return end();
            } else {
                continue;
            }
        }
        return Result<Token>(aggregate);
    }
};

template <class Rule>
SequenceRule<Rule> makeSequence(const bool matchRequired, std::vector<Rule>& rules)
{
    return SequenceRule<Rule>(rules, matchRequired);
}

template <class Rule>
SequenceRule<Rule> doMakeSequence(const bool matchRequired, std::vector<Rule>& rules)
{
    return makeSequence<Rule>(matchRequired, rules);
}

template <class Rule, typename... Rules>
SequenceRule<Rule> doMakeSequence(const bool matchRequired, std::vector<Rule>& rules, const Rule& rule, Rules... rest)
{
    rules.push_back(rule);
    return doMakeSequence<Rule>(matchRequired, rules, rest...);
}

template <class Rule, typename... Rules>
SequenceRule<Rule> makeSequence(const bool matchRequired, const Rule& rule, Rules... rest)
{
    std::vector<Rule> rules;
    return doMakeSequence<Rule>(matchRequired, rules, rule, rest...);
}

} // namespace sprout

#endif // SPROUT_SEQUENCERULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
