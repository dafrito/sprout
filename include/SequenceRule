#ifndef SPROUT_SEQUENCERULE_HEADER
#define SPROUT_SEQUENCERULE_HEADER

#include <vector>

#include "RuleTraits"
#include "Cursor"
#include "Result"

namespace sprout {

template <class Rule>
struct RuleEntry {
    Rule rule;
    bool required;

    template <class T>
    RuleEntry(const T& rule, bool required) :
        rule(rule),
        required(required)
    {
    }
};

struct InsertRequired
{
    bool value;

    InsertRequired(bool value) :
        value(value)
    {
    }
};

const InsertRequired Required(true);
const InsertRequired Optional(false);

/**
 * SequenceRule matches input against an ordered list of subrules.
 * All required subrules to match for SequenceRule to match.
 *
 * SequenceRule is populated using the insertion operator and
 * supports stream manipulator to specify optional rules.
 */
template <class Rule>
class SequenceRule : public RuleTraits<Rule>
{
    typedef typename Rule::token_type Token;
    typedef typename Rule::input_type Input;

    std::vector<RuleEntry<Rule>> _rules;

    bool _insertAsRequired;
public:
    template <class Container>
    SequenceRule(const Container& rules) :
        SequenceRule()
    {
        for (auto rule : rules) {
            *this << rule;
        }
    }

    SequenceRule() :
        _insertAsRequired(true)
    {
    }

    bool insertAsRequired() const
    {
        return _insertAsRequired;
    }

    SequenceRule& setInsertAsRequired(const bool requiredFlag)
    {
        _insertAsRequired = requiredFlag;
        return *this;
    }

    template <class T>
    SequenceRule& insert(const T& rule)
    {
        _rules.push_back(RuleEntry<Rule>(rule, insertAsRequired()));
        return *this;
    }

    const Result<Token> _eof;
    const Result<Token>& end() const
    {
        return _eof;
    }

    const Result<Token> parse(Cursor<Input>& iter) const
    {
        Result<Token> aggregate;
        for (auto entry : _rules) {
            auto tokens = entry.rule.parse(iter);
            if (tokens != entry.rule.end()) {
                aggregate.insert(tokens, entry.rule.end());
            } else if (entry.required) {
                return end();
            } else {
                continue;
            }
        }
        return aggregate;
    }
};

template <class Rule>
SequenceRule<Rule>& operator<<(SequenceRule<Rule>& sequence, const InsertRequired& requiredFlag)
{
    return sequence.setInsertAsRequired(requiredFlag.value);
}

/**
 * This rvalue implementation is needed for the SequenceRule() << subrule idiom.
 */
template <class Rule>
SequenceRule<Rule>& operator<<(SequenceRule<Rule>&& sequence, const InsertRequired& requiredFlag)
{
    return sequence.setInsertAsRequired(requiredFlag.value);
}

template <class Rule, class T>
SequenceRule<Rule>& operator<<(SequenceRule<Rule>& sequence, const T& rule)
{
    return sequence.insert(rule);
}

/**
 * This rvalue implementation is needed for the SequenceRule() << subrule idiom.
 */
template <class Rule, class T>
SequenceRule<Rule>& operator<<(SequenceRule<Rule>&& sequence, const T& rule)
{
    return sequence.insert(rule);
}

template <class Rule>
void populateSequence(SequenceRule<Rule>& sequence)
{
    // Do nothing
}

template <class Rule, class T, typename... Values>
void populateSequence(SequenceRule<Rule>& sequence, const T& value, Values... rest)
{
    sequence << value;
    populateSequence(sequence, rest...);
}

template <class Rule, typename... Values>
SequenceRule<Rule> makeSequence(const Rule& rule, Values... rest)
{
    SequenceRule<Rule> sequence;
    populateSequence(sequence, rule, rest...);
    return sequence;
}

template <class Rule>
SequenceRule<Rule> makeSequence()
{
    return SequenceRule<Rule>();
}

} // namespace sprout

#endif // SPROUT_SEQUENCERULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
