#ifndef SPROUT_PROXYRULE_HEADER
#define SPROUT_PROXYRULE_HEADER

#include <memory>

#include "Cursor"
#include "Result"
#include "SequenceRule"
#include "AlternativeRule"

namespace sprout {

template <class Input, class Token>
class RulePlaceholder {
public:
    virtual bool operator()(Cursor<Input>& iter, Result<Token>& result) const=0;
};

template <class Rule, class Input, class Token>
class RulePlaceholderImpl : public RulePlaceholder<Input, Token>
{
    Rule _rule;

public:
    RulePlaceholderImpl(const Rule& rule) :
        _rule(rule)
    {
    }

    bool operator()(Cursor<Input>& iter, Result<Token>& result) const
    {
        return _rule(iter, result);
    }
};

/**
 * ProxyRule wraps a specified rule, and proxies all parsing and results
 * to it. The reason to do this is to allow containers of heterogenous
 * rule types, which is a common need. In this way, ProxyRule is similar
 * to std::function.
 */
template <class Input, class Token>
class ProxyRule
{
public:
    typedef Input input_type;
    typedef Token token_type;

private:
    std::shared_ptr<RulePlaceholder<Input, Token>> _rule;

public:
    ProxyRule(const ProxyRule& other) :
        _rule(other._rule)
    {
    }

    template <class Rule, typename std::enable_if<
        !std::is_same<ProxyRule<Input, Token>, Rule>::value, int
    >::type = 0>
    ProxyRule(const Rule& rule) :
        _rule(new RulePlaceholderImpl<Rule, Input, Token>(rule))
    {
    }

    bool operator()(Cursor<Input>& iter, Result<Token>& result) const
    {
        return (*_rule)(iter, result);
    }
};

namespace make {

template <class Input, class Token, typename... Values>
SequenceRule<ProxyRule<Input, Token>> proxySequence(Values... rest)
{
    SequenceRule<ProxyRule<Input, Token>> sequence;
    populate(sequence, rest...);
    return sequence;
}

template <class Input, class Token, typename... Rules>
AlternativeRule<ProxyRule<Input, Token>> proxyAlternate(Rules... rest)
{
    AlternativeRule<ProxyRule<Input, Token>> alternative;
    populate(alternative, rest...);
    return alternative;
}

} // namespace make

} // namespace sprout

#endif // SPROUT_PROXYRULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
