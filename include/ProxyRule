#ifndef SPROUT_PROXYRULE_HEADER
#define SPROUT_PROXYRULE_HEADER

#include <memory>

#include "Cursor"
#include "Result"
#include "SequenceRule"

namespace sprout {

template <class Input, class Token>
class RulePlaceholder {
public:
    virtual const Result<Token>& end() const=0;
    virtual Result<Token> parse(Cursor<Input>& iter) const=0;
};

template <class Rule, class Input, class Token>
class RulePlaceholderImpl : public RulePlaceholder<Input, Token>
{
    Rule _rule;
    const Result<Token> _eof;

public:
    RulePlaceholderImpl(const Rule& rule) :
        _rule(rule)
    {
    }

    const Result<Token>& end() const
    {
        return _eof;
    }

    Result<Token> parse(Cursor<Input>& iter) const
    {
        auto tokens = _rule.parse(iter);
        if (tokens == _rule.end()) {
            return end();
        }
        return Result<Token>(tokens, _rule.end());
    }
};

/**
 * ProxyRule wraps a specified rule, and proxies all parsing and results
 * to it. The reason to do this is to allow containers of heterogenous
 * rule types, which is a common need. In this way, ProxyRule is similar
 * to std::function.
 */
template <class Input, class Token>
class ProxyRule
{
public:
    typedef Input input_type;
    typedef Token token_type;

private:
    std::shared_ptr<RulePlaceholder<Input, Token>> _rule;

public:
    ProxyRule(const ProxyRule& other) :
        _rule(other._rule)
    {
    }

    template <class Rule, typename std::enable_if<
        !std::is_same<ProxyRule<Input, Token>, Rule>::value, int
    >::type = 0>
    ProxyRule(const Rule& rule) :
        _rule(new RulePlaceholderImpl<Rule, Input, Token>(rule))
    {
    }

    const Result<Token>& end() const
    {
        return _rule->end();
    }

    const Result<Token> parse(Cursor<Input>& iter) const
    {
        return _rule->parse(iter);
    }
};

template <class Input, class Token, typename... Values>
SequenceRule<ProxyRule<Input, Token>> makeProxySequence(Values... rest)
{
    SequenceRule<ProxyRule<Input, Token>> sequence;
    populateSequence(sequence, rest...);
    return sequence;
}

} // namespace sprout

#endif // SPROUT_PROXYRULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
