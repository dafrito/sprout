#ifndef SPROUT_ALTERNATIVERULE_HEADER
#define SPROUT_ALTERNATIVERULE_HEADER

#include <vector>

#include "RuleTraits"
#include "Cursor"
#include "Result"

namespace sprout {

/**
 * AlternativeRule matches input against an ordered list of
 * candidate rules. The first rule that matches will provide
 * AlternativeRule's result.
 */
template <class Rule>
class AlternativeRule : public RuleTraits<Rule>
{
    typedef typename Rule::token_type Token;
    typedef typename Rule::input_type Input;

    std::vector<Rule> _rules;

public:
    template <class Container>
    AlternativeRule(const Container& rules) :
        _rules(rules)
    {
    }

    bool operator()(Cursor<Input>& iter, Result<Token>& result) const
    {
        for (auto rule : _rules) {
            if (rule(iter, result)) {
                return true;
            }
        }
        return false;
    }
};

namespace make {

template <class Rule>
AlternativeRule<Rule> alternate(std::vector<Rule>& rules)
{
    return AlternativeRule<Rule>(rules);
}

template <class Rule>
AlternativeRule<Rule> populateAlternate(std::vector<Rule>& rules)
{
    return alternate(rules);
}

template <class Rule, class T, typename... Rules>
AlternativeRule<Rule> populateAlternate(std::vector<Rule>& rules, const T& rule, Rules... rest)
{
    rules.push_back(rule);
    return populateAlternate(rules, rest...);
}

template <class Rule, typename... Rules>
AlternativeRule<Rule> alternate(const Rule& rule, Rules... rest)
{
    std::vector<Rule> rules;
    return populateAlternate(rules, rule, rest...);
}

} // namespace make

} // namespace sprout

#endif // SPROUT_ALTERNATIVERULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
