#ifndef SPROUT_EXACTMATCHRULE_HEADER
#define SPROUT_EXACTMATCHRULE_HEADER

#include <vector>
#include <algorithm>

#include "Cursor"

namespace sprout {

template <class Input, class Token>
class ExactMatchRule
{
public:
    typedef Input input_type;
    typedef Token token_type;

private:
    std::vector<Input> _target;
    Token _token;

public:
    void setTarget(const std::vector<Input>& target)
    {
        _target = target;
    }

    template <class Iterator>
    void setTarget(const Iterator& begin, const Iterator& end)
    {
        _target.clear();
        std::copy(begin, end, std::back_inserter(_target));
    }

    template <class Value>
    void setTarget(const Value& value)
    {
        setTarget(std::begin(value), std::end(value));
    }

    void setTarget(const char* value)
    {
        setTarget(std::string(value));
    }

    void setToken(const Token& token)
    {
        _token = token;
    }

    const Token* end() const
    {
        auto eof = &_token;
        return ++eof;
    }

    template <class Iterator>
    const Token* parse(Cursor<Iterator>& iter) const
    {
        auto mark = iter;
        int i = 0;
        while (i < _target.size()) {
            if (!iter || *iter++ != _target[i++]) {
                iter = mark;
                return end();
            }
        }
        return &_token;
    }
};

} // namespace sprout

#endif // SPROUT_EXACTMATCHRULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
