#ifndef SPROUT_DISCARDRULE_HEADER
#define SPROUT_DISCARDRULE_HEADER

#include <vector>
#include <algorithm>

#include "RuleTraits"
#include "SequenceRule"
#include "Cursor"
#include "Result"

namespace sprout {

/**
 * Runs the specified rule, but discards any matches. The cursor will be
 * moved on successful matches, so this is useful for skipping unnecessary
 * content like whitespace.
 */
template <
    class Rule,
    class Input = typename Rule::input_type,
    class Token = typename Rule::token_type
>
class DiscardRule
{
    const Rule _rule;

public:
    typedef Input input_type;
    typedef Token token_type;

    DiscardRule(const Rule& rule) :
        _rule(rule)
    {
    }

    bool operator()(Cursor<Input>& iter, Result<Token>& result) const
    {
        Result<Token> trash;
        _rule(iter, trash);
        return true;
    }
};

template <class Rule, class Subrule>
struct SequenceInserter<Rule, DiscardRule<Subrule>>
{
    static void insert(SequenceRule<Rule>& sequence, const DiscardRule<Subrule>& rule)
    {
        bool requiredFlag = sequence.insertAsRequired();
        sequence << Optional;
        sequence.insert(rule);
        sequence << (requiredFlag ? Required : Optional);
    }
};

namespace make {

template <class Rule>
DiscardRule<Rule> discard(const Rule& rule)
{
    return DiscardRule<Rule>(rule);
}

template <class Input, class Token, class Rule>
DiscardRule<Rule, Input, Token> discard(const Rule& rule)
{
    return DiscardRule<Rule, Input, Token>(rule);
}

} // namespace make

} // namespace sprout

#endif // SPROUT_DISCARDRULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
