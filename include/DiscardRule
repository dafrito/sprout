#ifndef SPROUT_DISCARDRULE_HEADER
#define SPROUT_DISCARDRULE_HEADER

#include <vector>
#include <algorithm>

#include "SequenceRule"
#include "Cursor"
#include "Result"

namespace sprout {

/**
 * Runs the specified rule, but discards any matches. The cursor will be
 * moved on successful matches, so this is useful for skipping unnecessary
 * content like whitespace.
 */
template <class Rule>
class DiscardRule
{
public:
    typedef typename Rule::token_type token_type;
    typedef typename Rule::input_type input_type;

private:
    typedef typename Rule::token_type Token;
    typedef typename Rule::input_type Input;

    Rule rule;

public:
    DiscardRule(const Rule& rule) :
        rule(rule)
    {
    }

    const Result<Token> _eof;
    const Result<Token>& end() const
    {
        return _eof;
    }

    const Result<Token> parse(Cursor<Input>& iter) const
    {
        rule.parse(iter);
        return end();
    }
};

// Ensure DiscardRule is always detected as optional
template <class Rule, class Subrule>
SequenceRule<Rule>& operator<<(SequenceRule<Rule>& sequence, const DiscardRule<Subrule>& rule)
{
    bool requiredFlag = sequence.insertAsRequired();
    sequence << Optional;
    sequence.insert(rule);
    return sequence << (requiredFlag ? Required : Optional);
}

/**
 * Ensure DiscardRule is always detected as optional.
 *
 * This rvalue implementation is needed for the SequenceRule() << makeDiscard() idiom.
 */
template <class Rule, class Subrule>
SequenceRule<Rule>& operator<<(SequenceRule<Rule>&& sequence, const DiscardRule<Subrule>& rule)
{
    bool requiredFlag = sequence.insertAsRequired();
    sequence << Optional;
    sequence.insert(rule);
    return sequence << (requiredFlag ? Required : Optional);
}

template <class Rule>
DiscardRule<Rule> makeDiscard(const Rule& rule)
{
    return DiscardRule<Rule>(rule);
}

} // namespace sprout

#endif // SPROUT_DISCARDRULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
