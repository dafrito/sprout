#ifndef SPROUT_REDUCERULE_HEADER
#define SPROUT_REDUCERULE_HEADER

#include "Cursor"
#include "Result"
#include "RuleTraits"

namespace sprout {

template <
    class Rule,
    class Reducer,
    class Token,
    class Input = typename Rule::input_type,
    class SubToken = typename Rule::token_type
>
class ReduceRule : public RuleTraits<Input, Token>
{
    typedef SubToken subtoken_type;

    const Reducer _reducer;
    const Rule _rule;

public:
    ReduceRule(const Reducer& reducer, const Rule& rule) :
        _reducer(reducer),
        _rule(rule)
    {
    }

    const Result<Token> _eof;
    const Result<Token>& end() const
    {
        return _eof;
    }

    bool operator()(Cursor<Input>& orig, Result<Token>& result) const
    {
        Result<SubToken> subresults;
        if (!_rule(orig, subresults)) {
            return false;
        }
        _reducer(result, subresults);
        return true;
    }
};

namespace make {

template <class Token, class Rule, class Reducer>
ReduceRule<Rule, Reducer, Token> reduce(const Reducer& reducer, const Rule& rule)
{
    return ReduceRule<Rule, Reducer, Token>(reducer, rule);
}

template <class Token, class Input, class SubToken, class Rule, class Reducer>
ReduceRule<Rule, Reducer, Token, Input, SubToken> reduce(const Reducer& reducer, const Rule& rule)
{
    return ReduceRule<Rule, Reducer, Token, Input, SubToken>(reducer, rule);
}

template <class Reducer, class Token>
class AggregatingReducer
{
    const Reducer _reducer;
public:
    AggregatingReducer (const Reducer& reducer) :
        _reducer(reducer)
    {
    }

    template <class SubToken>
    void operator()(Result<Token>& result, Result<SubToken>& subtokens) const
    {
        Token aggregate;
        for (auto token : subtokens) {
            _reducer(aggregate, token);
        }
        result.insert(aggregate);
    }
};

template <class Token, class Rule, class Reducer>
ReduceRule<Rule, AggregatingReducer<Reducer, Token>, Token>
aggregate(const Reducer& reducer, const Rule& rule)
{
    return reduce<Token>(AggregatingReducer<Reducer, Token>(reducer), rule);
}

template <class Token, class Input, class SubToken, class Rule, class Reducer>
ReduceRule<Rule, AggregatingReducer<Reducer, Token>, Token, Input, SubToken>
aggregate(const Reducer& reducer, const Rule& rule)
{
    return reduce<Token, Input, SubToken>(AggregatingReducer<Reducer, Token>(reducer), rule);
}

template <class Reducer, class Token>
class ConvertingReducer
{
    const Reducer _reducer;
public:
    ConvertingReducer (const Reducer& reducer) :
        _reducer(reducer)
    {
    }

    template <class SubToken>
    void operator()(Result<Token>& result, Result<SubToken>& subtokens) const
    {
        for (auto token : subtokens) {
            result.insert(_reducer(token));
        }
    }
};

template <class Token, class Rule, class Reducer>
ReduceRule<Rule, ConvertingReducer<Reducer, Token>, Token>
convert(const Reducer& reducer, const Rule& rule)
{
    return reduce<Token>(ConvertingReducer<Reducer, Token>(reducer), rule);
}

template <class Token, class Input, class SubToken, class Rule, class Reducer>
ReduceRule<Rule, ConvertingReducer<Reducer, Token>, Token, Input, SubToken>
convert(const Reducer& reducer, const Rule& rule)
{
    return reduce<Token, Input, SubToken>(ConvertingReducer<Reducer, Token>(reducer), rule);
}

} // namespace make

} // namespace sprout

#endif // SPROUT_REDUCERULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
