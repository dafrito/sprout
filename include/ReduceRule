#ifndef SPROUT_REDUCERULE_HEADER
#define SPROUT_REDUCERULE_HEADER

#include "Cursor"
#include "Result"
#include "RuleTraits"

namespace sprout {

template <
    class Rule,
    class Reducer,
    class Token = typename Rule::token_type
>
class ReduceRule : public RuleTraits<Rule>
{
    typedef typename Rule::input_type Input;
    typedef typename Rule::token_type SubToken;

    const Reducer _reducer;
    const Rule _rule;

public:
    ReduceRule(const Reducer& reducer, const Rule& rule) :
        _reducer(reducer),
        _rule(rule)
    {
    }

    const Result<Token> _eof;
    const Result<Token>& end() const
    {
        return _eof;
    }

    bool operator()(Cursor<Input>& orig, Result<Token>& result) const
    {
        Result<SubToken> subresults;
        if (!_rule(orig, subresults)) {
            return false;
        }
        _reducer(result, subresults);
        return true;
    }
};

namespace make {

template <class Token, class Rule, class Reducer>
ReduceRule<Rule, Reducer, Token> reduce(const Reducer& reducer, const Rule& rule)
{
    return ReduceRule<Rule, Reducer, Token>(reducer, rule);
}

template <class Reducer, class Token>
class SimpleReducer
{
    const Reducer _reducer;
public:
    SimpleReducer (const Reducer& reducer) :
        _reducer(reducer)
    {
    }

    template <class SubToken>
    void operator()(Result<Token>& result, Result<SubToken>& subtokens) const
    {
        Token aggregate;
        for (auto token : subtokens) {
            _reducer(aggregate, token);
        }
        result.insert(aggregate);
    }
};

template <class Token, class Rule, class Reducer>
ReduceRule<Rule, SimpleReducer<Reducer, Token>, Token> simpleReduce(const Reducer& reducer, const Rule& rule)
{
    return reduce<Token>(SimpleReducer<Reducer, Token>(reducer), rule);
}

} // namespace make

} // namespace sprout

#endif // SPROUT_REDUCERULE_HEADER

// vim: set ft=cpp ts=4 sw=4 :
