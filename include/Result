#ifndef SPROUT_RESULT_HEADER
#define SPROUT_RESULT_HEADER

#include <vector>
#include <iterator>
#include <algorithm>

namespace sprout {

/**
 * Result is used as a container of tokens in Sprout. I wish I could
 * have used a STL container instead of using a wrapper, but I desired
 * something that could both act as a container, as well as an iterator.
 */
template <class Token>
class Result : public std::iterator<std::input_iterator_tag, Token>
{
    typedef std::vector<Token> Tokens;
    std::shared_ptr<Tokens> _data;
    mutable int _pos;

public:
    Result() :
        _data(),
        _pos(0)
    {
    }

    Result(const Tokens& tokens) :
        _data(new Tokens(tokens)),
        _pos(0)
    {
    }

    template <class Iterator>
    Result(Iterator begin, Iterator end) :
        Result(Tokens())
    {
        insert(begin, end);
    }

    template <class T>
    Result(const Result<T>& begin, const Result<T>& end) :
        _data(new Tokens(*begin._data)),
        _pos(0)
    {
    }

    static const Tokens empty_tokens;

    typename Tokens::const_iterator begin() const
    {
        if (!_data) {
            return std::begin(empty_tokens);
        }
        return std::begin(*_data);
    }

    typename Tokens::const_iterator end() const
    {
        if (!_data) {
            return std::end(empty_tokens);
        }
        return std::end(*_data);
    }

    int pos() const
    {
        return _pos;
    }

    template <class Iterator>
    void insert(Iterator begin, Iterator end)
    {
        if (!_data) {
            _data = std::make_shared<Tokens>();
        }
        std::copy(begin, end, std::back_inserter(*_data));
    }

    operator bool() const
    {
        return _data && !_data->empty() && _pos < _data->size();
    }

    Token operator*() const
    {
        if (!_data) {
            throw std::runtime_error("An empty result must not be dereferenced");
        }
        if (_pos >= _data->size()) {
            throw std::runtime_error("Position must not be dereferenced out of range");
        }
        return (*_data)[_pos];
    }

    const Result<Token>& operator++() const
    {
        ++_pos;
        return *this;
    }

    const Result<Token> operator++(int) const
    {
        Result<Token> tmp(*this);
        ++(*this);
        return tmp;
    }

    const Result<Token>& operator+=(const int delta) const
    {
        _pos += delta;
        return *this;
    }

    const Result<Token>& operator-=(const int delta) const
    {
        return *this += -delta;
    }

    const Result<Token> operator+(const int delta) const
    {
        Result<Token> tmp(*this);
        tmp += delta;
        return tmp;
    }

    const Result<Token> operator-(const int delta) const
    {
        Result<Token> tmp(*this);
        tmp -= delta;
        return tmp;
    }

    template <class T>
    bool operator<(const Result<T>& other) const
    {
        return _data == other._data && pos() < other.pos();
    }

    template <class T>
    bool operator>(const Result<T>& other) const
    {
        return _data == other._data && pos() > other.pos();
    }

    template <class T>
    bool operator<=(const Result<T>& other) const
    {
        return _data == other._data && pos() <= other.pos();
    }

    template <class T>
    bool operator>=(const Result<T>& other) const
    {
        return _data == other._data && pos() >= other.pos();
    }

    template <class T>
    bool operator==(const Result<T>& other) const
    {
        if (!*this && !other) {
            return true;
        }
        return _data == other._data && pos() == other.pos();
    }

    template <class T>
    bool operator!=(const Result<T>& other) const
    {
        return !(*this == other);
    }
};

} // namespace sprout

#endif // SPROUT_RESULT_HEADER

// vim: set ft=cpp ts=4 sw=4 :
